import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';

export class DockerGenerator {
  constructor(aiAssistant, logger, outputDir = null) {
    this.aiAssistant = aiAssistant;
    this.logger = logger;
    this.projectRoot = outputDir || process.cwd();
  }

  async generateConfigurations(analysis, options) {
    const spinner = ora('Generating Docker configurations...').start();
    
    try {
      // Ensure output directory exists
      this.ensureDirectoryExists(this.projectRoot);
      
      // Generate Dockerfile based on project type
      await this.generateDockerfile(analysis);
      
      // Generate docker-compose.yml
      await this.generateDockerCompose(analysis);
      
      // Generate .dockerignore
      await this.generateDockerignore(analysis);
      
      // Generate docker-compose.override.yml for development
      await this.generateDockerComposeOverride(analysis);
      
      // Generate multi-stage production Dockerfile if needed
      if (options.production) {
        await this.generateProductionDockerfile(analysis);
      }
      
      // Generate README for Docker usage
      await this.generateDockerReadme(analysis);
      
      spinner.succeed('Docker configurations generated successfully');
      
      console.log(chalk.green('\nâœ… Generated Docker files:'));
      console.log(chalk.gray('ðŸ“ ./'));
      console.log(chalk.gray('â”œâ”€â”€ Dockerfile'));
      console.log(chalk.gray('â”œâ”€â”€ docker-compose.yml'));
      console.log(chalk.gray('â”œâ”€â”€ docker-compose.override.yml'));
      console.log(chalk.gray('â”œâ”€â”€ .dockerignore'));
      if (options.production) {
        console.log(chalk.gray('â”œâ”€â”€ Dockerfile.prod'));
      }
      console.log(chalk.gray('â””â”€â”€ DOCKER.md'));
      
    } catch (error) {
      spinner.fail('Docker generation failed');
      throw error;
    }
  }

  async generateDockerfile(analysis) {
    let dockerfile = '';
    
    if (analysis?.techStack?.includes('JavaScript/Node.js') || analysis?.techStack?.includes('Node.js')) {
      dockerfile = this.generateNodeDockerfile(analysis);
    } else if (analysis?.techStack?.includes('Python')) {
      dockerfile = this.generatePythonDockerfile(analysis);
    } else if (analysis?.techStack?.includes('Java')) {
      dockerfile = this.generateJavaDockerfile(analysis);
    } else if (analysis?.techStack?.includes('Go')) {
      dockerfile = this.generateGoDockerfile(analysis);
    } else {
      dockerfile = this.generateGenericDockerfile(analysis);
    }
    
    fs.writeFileSync(path.join(this.projectRoot, 'Dockerfile'), dockerfile);
  }

  generateNodeDockerfile(analysis) {
    const hasReact = analysis?.techStack?.includes('React');
    const hasNext = analysis?.techStack?.includes('Next.js');
    const nodeVersion = '18-alpine';
    
    return `# Multi-stage Dockerfile for Node.js application
# Generated by Rig CLI

# Build stage
FROM node:${nodeVersion} AS builder

WORKDIR /app

# Copy package files
COPY package*.json ./
${analysis?.packageManager === 'yarn' ? 'COPY yarn.lock ./' : ''}

# Install dependencies
${analysis?.packageManager === 'yarn' ? 'RUN yarn install --frozen-lockfile' : 'RUN npm ci --only=production'}

# Copy source code
COPY . .

${hasReact || hasNext ? `
# Build application
${analysis?.packageManager === 'yarn' ? 'RUN yarn build' : 'RUN npm run build'}
` : ''}

# Production stage
FROM node:${nodeVersion}

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nodejs -u 1001

WORKDIR /app

# Copy package files
COPY package*.json ./

# Install production dependencies only
${analysis?.packageManager === 'yarn' ? 'RUN yarn install --frozen-lockfile --production' : 'RUN npm ci --only=production && npm cache clean --force'}

# Copy built application
COPY --from=builder --chown=nodejs:nodejs /app${hasNext ? '/.next ./.next' : hasReact ? '/build ./build' : ' ./'}

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:3000/health || exit 1

# Start application
CMD ["${analysis?.packageManager === 'yarn' ? 'yarn' : 'npm'}", "start"]`;
  }

  generatePythonDockerfile(analysis) {
    const pythonVersion = '3.11-slim';
    const hasDjango = analysis?.techStack?.includes('Django');
    const hasFastAPI = analysis?.techStack?.includes('FastAPI');
    const hasFlask = analysis?.techStack?.includes('Flask');
    
    const defaultPort = hasDjango ? 8000 : hasFastAPI ? 8000 : hasFlask ? 5000 : 8000;
    
    return `# Multi-stage Dockerfile for Python application
# Generated by Rig CLI

FROM python:${pythonVersion}

# Set environment variables
ENV PYTHONDONTWRITEBYTECODE=1
ENV PYTHONUNBUFFERED=1

# Create non-root user
RUN adduser --disabled-password --gecos '' appuser

WORKDIR /app

# Install system dependencies
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        curl \\
        build-essential \\
    && apt-get clean \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements file
COPY requirements.txt .
${fs.existsSync(path.join(this.projectRoot, 'requirements-dev.txt')) ? 'COPY requirements-dev.txt .' : ''}

# Install Python dependencies
RUN pip install --no-cache-dir --upgrade pip \\
    && pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY --chown=appuser:appuser . .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE ${defaultPort}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:${defaultPort}/health || exit 1

# Start application
${hasDjango ? 'CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]' :
    hasFastAPI ? 'CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]' :
      hasFlask ? 'CMD ["python", "app.py"]' :
        'CMD ["python", "main.py"]'}`;
  }

  generateJavaDockerfile(analysis) {
    const javaVersion = '17-jre-slim';
    const hasMaven = analysis?.packageManager === 'maven';
    
    return `# Multi-stage Dockerfile for Java application
# Generated by Rig CLI

# Build stage
FROM openjdk:17-jdk-slim AS builder

WORKDIR /app

${hasMaven ? `
# Copy Maven files
COPY pom.xml .
COPY src ./src

# Build application
RUN ./mvnw clean package -DskipTests
` : `
# Copy Gradle files
COPY build.gradle settings.gradle gradlew ./
COPY gradle ./gradle
COPY src ./src

# Build application
RUN ./gradlew build -x test
`}

# Runtime stage
FROM openjdk:${javaVersion}

# Create non-root user
RUN adduser --disabled-password --gecos '' appuser

WORKDIR /app

# Copy built JAR
${hasMaven ? 
    'COPY --from=builder --chown=appuser:appuser /app/target/*.jar app.jar' : 
    'COPY --from=builder --chown=appuser:appuser /app/build/libs/*.jar app.jar'}

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:8080/actuator/health || exit 1

# Start application
CMD ["java", "-jar", "app.jar"]`;
  }

  generateGoDockerfile(analysis) {
    return `# Multi-stage Dockerfile for Go application
# Generated by Rig CLI

# Build stage
FROM golang:1.21-alpine AS builder

WORKDIR /app

# Install git (required for some Go modules)
RUN apk add --no-cache git

# Copy go mod files
COPY go.mod go.sum ./

# Download dependencies
RUN go mod download

# Copy source code
COPY . .

# Build application
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# Runtime stage
FROM alpine:latest

# Install ca-certificates for HTTPS requests
RUN apk --no-cache add ca-certificates curl

WORKDIR /root/

# Create non-root user
RUN adduser -D -s /bin/sh appuser

# Copy built binary
COPY --from=builder --chown=appuser:appuser /app/main .

# Switch to non-root user
USER appuser

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:8080/health || exit 1

# Start application
CMD ["./main"]`;
  }

  generateGenericDockerfile(analysis) {
    return `# Generic Dockerfile
# Generated by Rig CLI
# Please customize based on your application requirements

FROM ubuntu:22.04

# Install basic dependencies
RUN apt-get update \\
    && apt-get install -y --no-install-recommends \\
        curl \\
        wget \\
        ca-certificates \\
    && apt-get clean \\
    && rm -rf /var/lib/apt/lists/*

# Create non-root user
RUN useradd --create-home --shell /bin/bash appuser

WORKDIR /app

# Copy application files
COPY --chown=appuser:appuser . .

# Switch to non-root user
USER appuser

# Expose port (customize as needed)
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD curl -f http://localhost:8080/health || exit 1

# Start application (customize as needed)
CMD ["./start.sh"]`;
  }

  async generateDockerCompose(analysis) {
    const services = this.detectServices(analysis);
    
    const dockerCompose = `# Docker Compose configuration
# Generated by Rig CLI

version: '3.8'

services:
  # Main application
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "${this.getAppPort(analysis)}:${this.getAppPort(analysis)}"
    environment:
      - NODE_ENV=development
      ${this.generateEnvironmentVariables(analysis)}
    volumes:
      - .:/app
      - /app/node_modules
    depends_on:
      ${services.map(service => `- ${service.name}`).join('\n      ')}
    networks:
      - app-network
    restart: unless-stopped

${this.generateServiceConfigurations(services)}

networks:
  app-network:
    driver: bridge

volumes:
  ${services.filter(s => s.hasVolume).map(s => `${s.name}_data:`).join('\n  ')}`;
    
    fs.writeFileSync(path.join(this.projectRoot, 'docker-compose.yml'), dockerCompose);
  }

  async generateDockerComposeOverride(analysis) {
    const override = `# Docker Compose override for development
# Generated by Rig CLI

version: '3.8'

services:
  app:
    environment:
      - DEBUG=true
      - LOG_LEVEL=debug
    volumes:
      # Enable hot reload for development
      - .:/app
      - /app/node_modules
    command: ${this.getDevCommand(analysis)}
    ports:
      # Add debug port if applicable
      ${this.getDebugPort(analysis) ? `- "${this.getDebugPort(analysis)}:${this.getDebugPort(analysis)}"` : ''}

  # Override database for development (if applicable)
  ${this.hasDatabase(analysis) ? `
  postgres:
    environment:
      - POSTGRES_DB=myapp_dev
      - POSTGRES_USER=dev
      - POSTGRES_PASSWORD=devpass
  ` : ''}`;
    
    fs.writeFileSync(path.join(this.projectRoot, 'docker-compose.override.yml'), override);
  }

  async generateProductionDockerfile(analysis) {
    let dockerfile = '';
    
    if (analysis?.techStack?.includes('Node.js')) {
      dockerfile = this.generateProductionNodeDockerfile(analysis);
    } else if (analysis?.techStack?.includes('Python')) {
      dockerfile = this.generateProductionPythonDockerfile(analysis);
    } else {
      dockerfile = this.generateGenericProductionDockerfile(analysis);
    }
    
    fs.writeFileSync(path.join(this.projectRoot, 'Dockerfile.prod'), dockerfile);
  }

  generateProductionNodeDockerfile(analysis) {
    return `# Production-optimized Dockerfile for Node.js
# Generated by Rig CLI

FROM node:18-alpine AS base
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Dependencies stage
FROM base AS deps
COPY package*.json ./
${analysis?.packageManager === 'yarn' ? 'COPY yarn.lock ./' : ''}
RUN ${analysis?.packageManager === 'yarn' ? 'yarn install --frozen-lockfile' : 'npm ci'}

# Builder stage
FROM base AS builder
COPY --from=deps /app/node_modules ./node_modules
COPY . .
RUN ${analysis?.packageManager === 'yarn' ? 'yarn build' : 'npm run build'}

# Production stage
FROM base AS runner
ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nodejs

# Copy built application
COPY --from=builder --chown=nodejs:nodejs /app/public ./public
COPY --from=builder --chown=nodejs:nodejs /app/.next/standalone ./
COPY --from=builder --chown=nodejs:nodejs /app/.next/static ./.next/static

USER nodejs

EXPOSE 3000
ENV PORT=3000

CMD ["node", "server.js"]`;
  }

  async generateDockerignore(analysis) {
    const dockerignore = `# Docker ignore file
# Generated by Rig CLI

# Version control
.git
.gitignore
.gitattributes

# Documentation
README.md
CHANGELOG.md
LICENSE
*.md

# Docker files
Dockerfile*
docker-compose*
.dockerignore

# IDE files
.vscode
.idea
*.swp
*.swo

# OS files
.DS_Store
Thumbs.db

# Logs
*.log
logs/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Dependencies (will be installed in container)
node_modules/
__pycache__/
*.pyc
*.pyo
*.pyd
.Python

# Build outputs
build/
dist/
*.o
*.so

# Environment files
.env
.env.local
.env.*.local

# Test files
test/
tests/
*.test.js
*.spec.js
coverage/

# CI/CD
.github/
.gitlab-ci.yml
.travis.yml

${this.generateLanguageSpecificIgnores(analysis)}`;
    
    fs.writeFileSync(path.join(this.projectRoot, '.dockerignore'), dockerignore);
  }

  generateLanguageSpecificIgnores(analysis) {
    let ignores = '';
    
    if (analysis?.techStack?.includes('Node.js')) {
      ignores += `
# Node.js specific
.npm
.next/
out/`;
    }
    
    if (analysis?.techStack?.includes('Python')) {
      ignores += `
# Python specific
*.egg-info/
.pytest_cache/
.coverage
htmlcov/`;
    }
    
    if (analysis?.techStack?.includes('Java')) {
      ignores += `
# Java specific
target/
*.jar
*.war
*.ear`;
    }
    
    return ignores;
  }

  async generateDockerReadme(analysis) {
    const readme = `# Docker Configuration

This Docker configuration was generated by Rig CLI for your ${this.getProjectName(analysis)} project.

## Quick Start

### Development

\`\`\`bash
# Build and start all services
docker-compose up --build

# Run in background
docker-compose up -d

# View logs
docker-compose logs -f app

# Stop services
docker-compose down
\`\`\`

### Production

\`\`\`bash
# Build production image
docker build -f Dockerfile.prod -t ${this.getImageName(analysis)}:latest .

# Tag for GCP Container Registry (if using GCP)
docker tag ${this.getImageName(analysis)}:latest ${this.getRegistryUrl(analysis)}/${this.getImageName(analysis)}:latest

# Push to registry
docker push ${this.getRegistryUrl(analysis)}/${this.getImageName(analysis)}:latest

# Run production container
docker run -p ${this.getAppPort(analysis)}:${this.getAppPort(analysis)} ${this.getImageName(analysis)}:latest
\`\`\`

## Services

${this.generateServicesDocumentation(analysis)}

## Environment Variables

Copy \`.env.example\` to \`.env\` and customize:

${this.generateEnvironmentDocumentation(analysis)}

## Health Checks

All containers include health checks:
- **Interval**: 30 seconds
- **Timeout**: 3 seconds  
- **Retries**: 3 attempts

Check container health:
\`\`\`bash
docker-compose ps
\`\`\`

## Development Features

- **Hot reload**: Code changes trigger automatic reload
- **Volume mounting**: Local code is mounted for development
- **Debug ports**: Available for debugging (if applicable)

## Production Optimizations

- Multi-stage builds for smaller images
- Non-root user for security
- Health checks for reliability
- Optimized layer caching

## Troubleshooting

### Common Issues

1. **Port already in use**:
   \`\`\`bash
   docker-compose down
   # or change port in docker-compose.yml
   \`\`\`

2. **Permission denied**:
   \`\`\`bash
   sudo docker-compose down
   sudo chown -R $USER:$USER .
   \`\`\`

3. **Out of disk space**:
   \`\`\`bash
   docker system prune -a
   \`\`\`

### Useful Commands

\`\`\`bash
# Rebuild specific service
docker-compose build app

# Execute command in running container
docker-compose exec app bash

# View container resource usage
docker stats

# Remove all containers and volumes
docker-compose down -v --remove-orphans
\`\`\`

## Generated by Rig CLI

This Docker configuration was automatically generated by Rig CLI.
- Run \`rig generate docker\` to regenerate
- Run \`rig generate kubernetes\` to create K8s manifests
- Run \`rig security --scan\` to check for security issues
`;
    
    fs.writeFileSync(path.join(this.projectRoot, 'DOCKER.md'), readme);
  }

  // Helper methods
  detectServices(analysis) {
    const services = [];
    
    // Database service
    if (this.hasDatabase(analysis)) {
      services.push({
        name: 'postgres',
        type: 'database',
        hasVolume: true,
        port: 5432
      });
    }
    
    // Redis service
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      services.push({
        name: 'redis',
        type: 'cache',
        hasVolume: true,
        port: 6379
      });
    }
    
    return services;
  }

  generateServiceConfigurations(services) {
    return services.map(service => {
      switch (service.type) {
      case 'database':
        return `
  ${service.name}:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    volumes:
      - ${service.name}_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - app-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 10s
      timeout: 5s
      retries: 5`;
        
      case 'cache':
        return `
  ${service.name}:
    image: redis:7-alpine
    volumes:
      - ${service.name}_data:/data
    ports:
      - "6379:6379"
    networks:
      - app-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5`;
        
      default:
        return '';
      }
    }).join('\n');
  }

  getAppPort(analysis) {
    if (analysis?.techStack?.includes('Express.js') || analysis?.techStack?.includes('React')) {
      return 3000;
    } else if (analysis?.techStack?.includes('Django') || analysis?.techStack?.includes('FastAPI')) {
      return 8000;
    } else if (analysis?.techStack?.includes('Flask')) {
      return 5000;
    }
    return 8080;
  }

  getDevCommand(analysis) {
    if (analysis?.packageManager === 'yarn') {
      return 'yarn dev';
    } else if (analysis?.techStack?.includes('Node.js')) {
      return 'npm run dev';
    } else if (analysis?.techStack?.includes('Python')) {
      return 'python manage.py runserver 0.0.0.0:8000';
    }
    return 'npm start';
  }

  getDebugPort(analysis) {
    if (analysis?.techStack?.includes('Node.js')) {
      return 9229;
    } else if (analysis?.techStack?.includes('Python')) {
      return 5678;
    }
    return null;
  }

  hasDatabase(analysis) {
    return analysis?.dependencies?.some(dep => 
      dep.includes('postgres') || dep.includes('mysql') || dep.includes('mongodb') ||
      dep.includes('psycopg2') || dep.includes('django') || dep.includes('sqlalchemy')
    );
  }

  generateEnvironmentVariables(analysis) {
    let envVars = '';
    
    if (this.hasDatabase(analysis)) {
      envVars += '- DATABASE_URL=postgresql://postgres:postgres@postgres:5432/myapp\n      ';
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      envVars += '- REDIS_URL=redis://redis:6379\n      ';
    }
    
    return envVars || '# Add your environment variables here';
  }

  generateServicesDocumentation(analysis) {
    let docs = '- **app**: Main application container\n';
    
    if (this.hasDatabase(analysis)) {
      docs += '- **postgres**: PostgreSQL database\n';
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      docs += '- **redis**: Redis cache/session store\n';
    }
    
    return docs;
  }

  getImageName(analysis) {
    return this.getProjectName(analysis);
  }

  getRegistryUrl(analysis) {
    if (analysis?.cloud?.projectId && analysis.cloud.projectId !== 'your-gcp-project-id') {
      return `gcr.io/${analysis.cloud.projectId}`;
    }
    return 'gcr.io/your-gcp-project-id';
  }

  generateEnvironmentDocumentation(analysis) {
    let docs = '';
    
    if (this.hasDatabase(analysis)) {
      docs += '- `DATABASE_URL`: Database connection string\n';
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      docs += '- `REDIS_URL`: Redis connection string\n';
    }
    
    docs += '- `NODE_ENV`: Environment (development/production)\n';
    docs += '- `LOG_LEVEL`: Logging level\n';
    
    return docs;
  }

  getProjectName(analysis) {
    // Prefer GCP project name if available
    if (analysis?.infrastructure?.projectName) {
      return analysis.infrastructure.projectName;
    }
    
    // Get from environment variable (GCP project)
    const gcpProject = process.env.GCP_PROJECT_ID;
    if (gcpProject) {
      return gcpProject;
    }
    
    // Try to get from package.json name, but avoid CLI tool names
    if (analysis?.projectName && 
        analysis.projectName !== 'devops-cli' && 
        analysis.projectName !== 'rig-cli') {
      return analysis.projectName;
    }
    
    // Fallback to current directory name only if it's not the CLI tool
    const dirName = path.basename(process.cwd());
    if (dirName !== 'devops-cli' && dirName !== 'rig-cli') {
      return dirName;
    }
    
    // Final fallback
    return 'my-app';
  }

  ensureDirectoryExists(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }
}