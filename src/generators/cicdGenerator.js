import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import ora from 'ora';
import inquirer from 'inquirer';

export class CICDGenerator {
  constructor(aiAssistant, logger) {
    this.aiAssistant = aiAssistant;
    this.logger = logger;
    this.projectRoot = process.cwd();
  }

  async generateInteractive(analysis, options) {
    const { platform } = await inquirer.prompt([
      {
        type: 'list',
        name: 'platform',
        message: 'Which CI/CD platform would you like to use?',
        choices: [
          { name: 'üêô GitHub Actions', value: 'github' },
          { name: 'ü¶ä GitLab CI/CD', value: 'gitlab' },
          { name: 'üî∑ Azure DevOps', value: 'azure' },
          { name: 'üë∑ Jenkins', value: 'jenkins' }
        ]
      }
    ]);

    switch (platform) {
    case 'github':
      await this.generateGitHubActions(analysis, options);
      break;
    case 'gitlab':
      await this.generateGitLabCI(analysis, options);
      break;
    case 'azure':
      await this.generateAzureDevOps(analysis, options);
      break;
    case 'jenkins':
      await this.generateJenkins(analysis, options);
      break;
    }
  }

  async generateGitHubActions(analysis, options) {
    const workflowsDir = path.join(this.projectRoot, '.github', 'workflows');
    
    const spinner = ora('Generating GitHub Actions workflows...').start();
    
    try {
      // Create workflows directory
      this.ensureDirectoryExists(workflowsDir);
      
      // Generate main CI/CD workflow
      await this.generateGitHubMainWorkflow(workflowsDir, analysis, options);
      
      // Generate security scanning workflow
      await this.generateGitHubSecurityWorkflow(workflowsDir, analysis);
      
      // Generate dependency update workflow
      await this.generateGitHubDependabotWorkflow(analysis);
      
      // Generate deployment workflows for different environments
      await this.generateGitHubDeploymentWorkflows(workflowsDir, analysis);
      
      spinner.succeed('GitHub Actions workflows generated successfully');
      
      console.log(chalk.green('\n‚úÖ Generated GitHub Actions files:'));
      console.log(chalk.gray('üìÅ .github/'));
      console.log(chalk.gray('‚îú‚îÄ‚îÄ workflows/'));
      console.log(chalk.gray('‚îÇ   ‚îú‚îÄ‚îÄ ci-cd.yml'));
      console.log(chalk.gray('‚îÇ   ‚îú‚îÄ‚îÄ security.yml'));
      console.log(chalk.gray('‚îÇ   ‚îú‚îÄ‚îÄ deploy-staging.yml'));
      console.log(chalk.gray('‚îÇ   ‚îî‚îÄ‚îÄ deploy-production.yml'));
      console.log(chalk.gray('‚îî‚îÄ‚îÄ dependabot.yml'));
      
    } catch (error) {
      spinner.fail('GitHub Actions generation failed');
      throw error;
    }
  }

  async generateGitHubMainWorkflow(workflowsDir, analysis, options) {
    const workflow = `# Main CI/CD Pipeline
# Generated by Rig CLI

name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: \${{ github.repository }}

jobs:
  test:
    name: Test
    runs-on: ubuntu-latest
    
    services:
      ${this.generateGitHubServices(analysis)}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup ${this.getRuntime(analysis)}
      ${this.getGitHubRuntimeSetup(analysis)}
    
    - name: Cache dependencies
      ${this.getGitHubCacheSetup(analysis)}
    
    - name: Install dependencies
      run: ${this.getInstallCommand(analysis)}
    
    - name: Run linter
      run: ${this.getLintCommand(analysis)}
    
    - name: Run tests
      run: ${this.getTestCommand(analysis)}
      env:
        ${this.generateTestEnvironmentVariables(analysis)}
    
    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          coverage/
          test-results.xml

  security:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Run security audit
      run: ${this.getSecurityAuditCommand(analysis)}
    
    - name: Upload security results
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: security-results.sarif

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [test, security]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    outputs:
      image-tag: \${{ steps.meta.outputs.tags }}
      image-digest: \${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: \${{ env.REGISTRY }}
        username: \${{ github.actor }}
        password: \${{ secrets.GITHUB_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: \${{ env.REGISTRY }}/\${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: \${{ steps.meta.outputs.tags }}
        labels: \${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to staging
      run: |
        echo "Deploying \${{ needs.build.outputs.image-tag }} to staging"
        # Add your staging deployment commands here
        ${this.getStagingDeployCommand(analysis)}

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build]
    if: github.ref == 'refs/heads/main'
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to production
      run: |
        echo "Deploying \${{ needs.build.outputs.image-tag }} to production"
        # Add your production deployment commands here
        ${this.getProductionDeployCommand(analysis)}`;
    
    fs.writeFileSync(path.join(workflowsDir, 'ci-cd.yml'), workflow);
  }

  async generateGitHubSecurityWorkflow(workflowsDir, analysis) {
    const workflow = `# Security Scanning Workflow
# Generated by Rig CLI

name: Security

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 2 * * 1'  # Weekly on Mondays at 2 AM

jobs:
  codeql:
    name: CodeQL Analysis
    runs-on: ubuntu-latest
    
    strategy:
      fail-fast: false
      matrix:
        language: [${this.getCodeQLLanguages(analysis)}]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        languages: \${{ matrix.language }}
    
    - name: Autobuild
      uses: github/codeql-action/autobuild@v3
    
    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3

  dependency-check:
    name: Dependency Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup ${this.getRuntime(analysis)}
      ${this.getGitHubRuntimeSetup(analysis)}
    
    - name: Install dependencies
      run: ${this.getInstallCommand(analysis)}
    
    - name: Run dependency audit
      run: ${this.getDependencyAuditCommand(analysis)}

  container-scan:
    name: Container Security Scan
    runs-on: ubuntu-latest
    if: github.event_name == 'push'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Build Docker image
      run: docker build -t local-image .
    
    - name: Scan image with Trivy
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: local-image
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  secrets-scan:
    name: Secrets Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: TruffleHog OSS
      uses: trufflesecurity/trufflehog@main
      with:
        path: ./
        base: main
        head: HEAD
        extra_args: --debug --only-verified`;
    
    fs.writeFileSync(path.join(workflowsDir, 'security.yml'), workflow);
  }

  async generateGitHubDependabotWorkflow(analysis) {
    const dependabotDir = path.join(this.projectRoot, '.github');
    this.ensureDirectoryExists(dependabotDir);
    
    const config = `# Dependabot configuration
# Generated by Rig CLI

version: 2
updates:
  ${this.generateDependabotUpdates(analysis)}

  # Docker dependencies
  - package-ecosystem: "docker"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 5

  # GitHub Actions
  - package-ecosystem: "github-actions"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 5`;
    
    fs.writeFileSync(path.join(dependabotDir, 'dependabot.yml'), config);
  }

  async generateGitHubDeploymentWorkflows(workflowsDir, analysis) {
    // Staging deployment workflow
    const stagingWorkflow = `# Staging Deployment
# Generated by Rig CLI

name: Deploy to Staging

on:
  push:
    branches: [ develop ]

jobs:
  deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubectl
      run: |
        echo "\${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to staging
      run: |
        # Update image tag in manifests
        sed -i "s|image:.*|image: ghcr.io/\${{ github.repository }}:\${{ github.sha }}|g" k8s/overlays/staging/kustomization.yaml
        
        # Apply manifests
        kubectl apply -k k8s/overlays/staging
        
        # Wait for rollout
        kubectl rollout status deployment/\${{ github.event.repository.name }} -n staging
    
    - name: Run health check
      run: |
        kubectl get pods -n staging
        # Add custom health checks here`;
    
    fs.writeFileSync(path.join(workflowsDir, 'deploy-staging.yml'), stagingWorkflow);
    
    // Production deployment workflow
    const productionWorkflow = `# Production Deployment
# Generated by Rig CLI

name: Deploy to Production

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.28.0'
    
    - name: Configure kubectl
      run: |
        echo "\${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > kubeconfig
        export KUBECONFIG=kubeconfig
    
    - name: Deploy to production
      run: |
        # Update image tag in manifests
        sed -i "s|image:.*|image: ghcr.io/\${{ github.repository }}:\${{ github.sha }}|g" k8s/overlays/prod/kustomization.yaml
        
        # Apply manifests
        kubectl apply -k k8s/overlays/prod
        
        # Wait for rollout
        kubectl rollout status deployment/\${{ github.event.repository.name }} -n production
    
    - name: Run health check
      run: |
        kubectl get pods -n production
        # Add custom health checks here
    
    - name: Notify deployment
      uses: 8398a7/action-slack@v3
      if: always()
      with:
        status: \${{ job.status }}
        text: "Production deployment \${{ job.status }}"
      env:
        SLACK_WEBHOOK_URL: \${{ secrets.SLACK_WEBHOOK }}`;
    
    fs.writeFileSync(path.join(workflowsDir, 'deploy-production.yml'), productionWorkflow);
  }

  async generateGitLabCI(analysis, options) {
    const spinner = ora('Generating GitLab CI/CD pipeline...').start();
    
    try {
      const gitlabCIConfig = this.generateGitLabCIConfig(analysis, options);
      fs.writeFileSync(path.join(this.projectRoot, '.gitlab-ci.yml'), gitlabCIConfig);
      
      spinner.succeed('GitLab CI/CD pipeline generated successfully');
      
      console.log(chalk.green('\n‚úÖ Generated GitLab CI/CD file:'));
      console.log(chalk.gray('üìÅ ./'));
      console.log(chalk.gray('‚îî‚îÄ‚îÄ .gitlab-ci.yml'));
      
    } catch (error) {
      spinner.fail('GitLab CI/CD generation failed');
      throw error;
    }
  }

  generateGitLabCIConfig(analysis, options) {
    return `# GitLab CI/CD Pipeline
# Generated by Rig CLI

stages:
  - test
  - security
  - build
  - deploy

variables:
  DOCKER_IMAGE: \$CI_REGISTRY_IMAGE
  DOCKER_TAG: \$CI_COMMIT_SHA

# Test stage
test:
  stage: test
  image: ${this.getGitLabImage(analysis)}
  
  services:
    ${this.generateGitLabServices(analysis)}
  
  variables:
    ${this.generateTestEnvironmentVariables(analysis)}
  
  before_script:
    - ${this.getInstallCommand(analysis)}
  
  script:
    - ${this.getLintCommand(analysis)}
    - ${this.getTestCommand(analysis)}
  
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit:
        - test-results.xml
    paths:
      - coverage/
    expire_in: 30 days
  
  coverage: '/Coverage: \\d+\\.\\d+%/'

# Security scanning
security:
  stage: security
  image: registry.gitlab.com/security-products/sast:latest
  
  script:
    - ${this.getSecurityAuditCommand(analysis)}
  
  artifacts:
    reports:
      sast: gl-sast-report.json
    expire_in: 7 days

dependency_scanning:
  stage: security
  image: registry.gitlab.com/security-products/dependency-scanning:latest
  
  script:
    - /analyzer run
  
  artifacts:
    reports:
      dependency_scanning: gl-dependency-scanning-report.json
    expire_in: 7 days

# Build Docker image
build:
  stage: build
  image: docker:latest
  
  services:
    - docker:dind
  
  before_script:
    - docker login -u \$CI_REGISTRY_USER -p \$CI_REGISTRY_PASSWORD \$CI_REGISTRY
  
  script:
    - docker build -t \$DOCKER_IMAGE:\$DOCKER_TAG .
    - docker push \$DOCKER_IMAGE:\$DOCKER_TAG
    - docker tag \$DOCKER_IMAGE:\$DOCKER_TAG \$DOCKER_IMAGE:latest
    - docker push \$DOCKER_IMAGE:latest
  
  only:
    - main
    - develop

# Deploy to staging
deploy_staging:
  stage: deploy
  image: bitnami/kubectl:latest
  
  script:
    - kubectl config use-context \$KUBE_CONTEXT_STAGING
    - kubectl set image deployment/app app=\$DOCKER_IMAGE:\$DOCKER_TAG -n staging
    - kubectl rollout status deployment/app -n staging
  
  environment:
    name: staging
    url: https://staging.example.com
  
  only:
    - develop

# Deploy to production
deploy_production:
  stage: deploy
  image: bitnami/kubectl:latest
  
  script:
    - kubectl config use-context \$KUBE_CONTEXT_PRODUCTION
    - kubectl set image deployment/app app=\$DOCKER_IMAGE:\$DOCKER_TAG -n production
    - kubectl rollout status deployment/app -n production
  
  environment:
    name: production
    url: https://production.example.com
  
  when: manual
  only:
    - main`;
  }

  // Helper methods for different platforms and languages
  getRuntime(analysis) {
    if (analysis?.techStack?.includes('Node.js')) return 'Node.js';
    if (analysis?.techStack?.includes('Python')) return 'Python';
    if (analysis?.techStack?.includes('Java')) return 'Java';
    if (analysis?.techStack?.includes('Go')) return 'Go';
    return 'Node.js';
  }

  getGitHubRuntimeSetup(analysis) {
    if (analysis?.techStack?.includes('Node.js')) {
      return `uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: '${analysis?.packageManager || 'npm'}'`;
    } else if (analysis?.techStack?.includes('Python')) {
      return `uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        cache: 'pip'`;
    } else if (analysis?.techStack?.includes('Java')) {
      return `uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'`;
    } else if (analysis?.techStack?.includes('Go')) {
      return `uses: actions/setup-go@v4
      with:
        go-version: '1.21'`;
    }
    return `uses: actions/setup-node@v4
      with:
        node-version: '18'
        cache: 'npm'`;
  }

  getGitHubCacheSetup(analysis) {
    if (analysis?.techStack?.includes('Node.js')) {
      const cacheKey = analysis?.packageManager === 'yarn' ? 'yarn' : 'npm';
      return `uses: actions/cache@v3
      with:
        path: ~/.${cacheKey}
        key: \${{ runner.os }}-${cacheKey}-\${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          \${{ runner.os }}-${cacheKey}-`;
    }
    return '# No cache setup needed';
  }

  getInstallCommand(analysis) {
    if (analysis?.packageManager === 'yarn') return 'yarn install --frozen-lockfile';
    if (analysis?.techStack?.includes('Node.js')) return 'npm ci';
    if (analysis?.techStack?.includes('Python')) return 'pip install -r requirements.txt';
    if (analysis?.techStack?.includes('Java') && analysis?.packageManager === 'maven') return './mvnw install -DskipTests';
    if (analysis?.techStack?.includes('Java')) return './gradlew build -x test';
    if (analysis?.techStack?.includes('Go')) return 'go mod download';
    return 'npm ci';
  }

  getLintCommand(analysis) {
    if (analysis?.packageManager === 'yarn') return 'yarn lint';
    if (analysis?.techStack?.includes('Node.js')) return 'npm run lint';
    if (analysis?.techStack?.includes('Python')) return 'flake8 . && black --check .';
    return 'npm run lint || echo "No lint script found"';
  }

  getTestCommand(analysis) {
    if (analysis?.packageManager === 'yarn') return 'yarn test';
    if (analysis?.techStack?.includes('Node.js')) return 'npm test';
    if (analysis?.techStack?.includes('Python')) return 'python -m pytest --cov=. --cov-report=xml';
    if (analysis?.techStack?.includes('Java') && analysis?.packageManager === 'maven') return './mvnw test';
    if (analysis?.techStack?.includes('Java')) return './gradlew test';
    if (analysis?.techStack?.includes('Go')) return 'go test ./...';
    return 'npm test';
  }

  getSecurityAuditCommand(analysis) {
    if (analysis?.packageManager === 'yarn') return 'yarn audit --audit-level moderate';
    if (analysis?.techStack?.includes('Node.js')) return 'npm audit --audit-level moderate';
    if (analysis?.techStack?.includes('Python')) return 'safety check -r requirements.txt';
    return 'npm audit --audit-level moderate';
  }

  getDependencyAuditCommand(analysis) {
    if (analysis?.packageManager === 'yarn') return 'yarn audit';
    if (analysis?.techStack?.includes('Node.js')) return 'npm audit';
    if (analysis?.techStack?.includes('Python')) return 'pip-audit';
    return 'npm audit';
  }

  generateGitHubServices(analysis) {
    let services = '';
    
    if (this.hasDatabase(analysis)) {
      services += `postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      `;
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      services += `redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      `;
    }
    
    return services || '# No services needed';
  }

  generateTestEnvironmentVariables(analysis) {
    let envVars = 'NODE_ENV: test\n        ';
    
    if (this.hasDatabase(analysis)) {
      envVars += 'DATABASE_URL: postgresql://postgres:postgres@localhost:5432/testdb\n        ';
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      envVars += 'REDIS_URL: redis://localhost:6379\n        ';
    }
    
    return envVars;
  }

  getCodeQLLanguages(analysis) {
    const languages = [];
    
    if (analysis?.techStack?.includes('Node.js')) languages.push('\'javascript\'');
    if (analysis?.techStack?.includes('Python')) languages.push('\'python\'');
    if (analysis?.techStack?.includes('Java')) languages.push('\'java\'');
    if (analysis?.techStack?.includes('Go')) languages.push('\'go\'');
    
    return languages.join(', ') || '\'javascript\'';
  }

  generateDependabotUpdates(analysis) {
    let updates = '';
    
    if (analysis?.techStack?.includes('Node.js')) {
      updates += `- package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
  `;
    }
    
    if (analysis?.techStack?.includes('Python')) {
      updates += `- package-ecosystem: "pip"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
  `;
    }
    
    if (analysis?.techStack?.includes('Java') && analysis?.packageManager === 'maven') {
      updates += `- package-ecosystem: "maven"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
  `;
    }
    
    if (analysis?.techStack?.includes('Java') && analysis?.packageManager === 'gradle') {
      updates += `- package-ecosystem: "gradle"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10
  `;
    }
    
    return updates || `- package-ecosystem: "npm"
    directory: "/"
    schedule:
      interval: "weekly"
    open-pull-requests-limit: 10`;
  }

  getStagingDeployCommand(analysis) {
    return `# kubectl set image deployment/app app=ghcr.io/\${{ github.repository }}:\${{ github.sha }} -n staging
        # kubectl rollout status deployment/app -n staging`;
  }

  getProductionDeployCommand(analysis) {
    return `# kubectl set image deployment/app app=ghcr.io/\${{ github.repository }}:\${{ github.sha }} -n production
        # kubectl rollout status deployment/app -n production`;
  }

  getGitLabImage(analysis) {
    if (analysis?.techStack?.includes('Node.js')) return 'node:18-alpine';
    if (analysis?.techStack?.includes('Python')) return 'python:3.11-slim';
    if (analysis?.techStack?.includes('Java')) return 'openjdk:17-jdk-slim';
    if (analysis?.techStack?.includes('Go')) return 'golang:1.21-alpine';
    return 'node:18-alpine';
  }

  generateGitLabServices(analysis) {
    let services = '';
    
    if (this.hasDatabase(analysis)) {
      services += `- postgres:15
  `;
    }
    
    if (analysis?.dependencies?.some(dep => dep.includes('redis'))) {
      services += `- redis:7
  `;
    }
    
    return services || '# No services needed';
  }

  hasDatabase(analysis) {
    return analysis?.dependencies?.some(dep => 
      dep.includes('postgres') || dep.includes('mysql') || dep.includes('mongodb') ||
      dep.includes('psycopg2') || dep.includes('django') || dep.includes('sqlalchemy')
    );
  }

  ensureDirectoryExists(dir) {
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
  }
}